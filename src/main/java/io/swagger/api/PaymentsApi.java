/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.36).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api;

import io.swagger.model.AssignSuspensePaymentHandler;
import io.swagger.model.Payment;
import io.swagger.model.PaymentAuditDetailsType;
import io.swagger.model.PaymentDetails;
import io.swagger.model.PaymentList;
import io.swagger.model.RecyclePayment;
import org.springframework.core.io.Resource;
import io.swagger.model.ReversePayment;
import io.swagger.model.SuspenseAccount;
import io.swagger.model.User;
import io.swagger.model.WithdrawPayment;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.CookieValue;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2022-12-14T12:38:42.664Z[GMT]")
@Validated
public interface PaymentsApi {

    @Operation(summary = "Allocate a Suspended Payment to an Account", description = "Allocates a suspended payment to the specified account.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "201", description = "The suspended payment was successfully allocated to the account.", content = @Content(mediaType = "application/xml", schema = @Schema(implementation = Resource.class))),
        
        @ApiResponse(responseCode = "400", description = "The request isn't valid."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/allocate",
        produces = { "application/xml", "application/json" }, 
        consumes = { "application/xml", "application/json" }, 
        method = RequestMethod.POST)
    ResponseEntity<Resource> allocateSuspendedPayment(@Parameter(in = ParameterIn.QUERY, description = "Whether to validate that the account has an open bill that is due. When <b>validate=openBills</b>, it checks if the account has any open due bills. For any other value, validation is skipped." ,schema=@Schema()) @Valid @RequestParam(value = "validate", required = false) String validate, @Parameter(in = ParameterIn.DEFAULT, description = "Information for allocating the suspended payment. The schema payload should contain the following&colon; <ul><li>The event resource associated with the suspended account</li><li>The amount to allocate to the target account</li><li>The target account's currency</li><li>The total amount to allocate from suspense</li><li>(Optional) The bill items along with the amount to allocate to each one in case of manual allocation of items</li></ul>", schema=@Schema()) @Valid @RequestBody RecyclePayment body);


    @Operation(summary = "Assign a Handler to Suspended Payment", description = "Assigns an authorized handler to manage the suspended payment.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "201", description = "A handler was successfully assigned to the suspended payment."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/assignhandler",
        consumes = { "application/xml", "application/json" }, 
        method = RequestMethod.POST)
    ResponseEntity<Void> assignSuspensePaymentHandler(@Parameter(in = ParameterIn.DEFAULT, description = "The authorized payment handler to assign.", schema=@Schema()) @Valid @RequestBody AssignSuspensePaymentHandler body);


    @Operation(summary = "Get Audit Trails for a Transaction", description = "Gets the list of audit details for the entire lifecycle of the payment for the specified transaction ID.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The audit trails were returned successfully.", content = @Content(mediaType = "application/xml", schema = @Schema(implementation = PaymentAuditDetailsType.class))),
        
        @ApiResponse(responseCode = "400", description = "The request isn't valid."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/audit/{id}",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<PaymentAuditDetailsType> getAuditTrails(@Parameter(in = ParameterIn.PATH, description = "The ID of the payment transaction, such as T1,e7,0.", required=true, schema=@Schema()) @PathVariable("id") String id);


    @Operation(summary = "Get Unallocated Payments for a Bill Unit", description = "Gets the list of unallocated payments for the specified bill unit.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The unallocated payments were returned successfully.", content = @Content(mediaType = "application/xml", array = @ArraySchema(schema = @Schema(implementation = PaymentList.class)))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/billunit/{id}",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<PaymentList>> getBillUnitPayments(@Parameter(in = ParameterIn.PATH, description = "The ID of the bill unit.", required=true, schema=@Schema()) @PathVariable("id") String id, @Parameter(in = ParameterIn.QUERY, description = "The type of payments to get. The only supported value is <b>type=unallocated</b>." ,schema=@Schema()) @Valid @RequestParam(value = "type", required = false) String type);


    @Operation(summary = "Get Payments for a Bill", description = "Gets the list of payments applied to the specified bill.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The payments were returned successfully.", content = @Content(mediaType = "application/xml", array = @ArraySchema(schema = @Schema(implementation = PaymentList.class)))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/bill/{id}",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<PaymentList>> getPaymentAppliedSummary(@Parameter(in = ParameterIn.PATH, description = "The ID of the bill.", required=true, schema=@Schema()) @PathVariable("id") String id, @Parameter(in = ParameterIn.QUERY, description = "The number of payments to retrieve." ,schema=@Schema()) @Valid @RequestParam(value = "number", required = false) String number);


    @Operation(summary = "Get Details for a Payment", description = "Gets the details about a payment.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The payment details were returned successfully.", content = @Content(mediaType = "application/xml", schema = @Schema(implementation = PaymentDetails.class))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/{id}",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<PaymentDetails> getPaymentDetails(@Parameter(in = ParameterIn.PATH, description = "The ID of the payment or reversal to get, such as 0.0.0.1+-item-payment+294053389732590266.", required=true, schema=@Schema()) @PathVariable("id") String id);


    @Operation(summary = "Get Users with Suspend Permission", description = "Gets the list of users who have suspense payment management (<b>SuspenseAllocate</b>) permissions.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The list of users was returned successfully.", content = @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = User.class)))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/users",
        produces = { "application/json", "application/xml" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<User>> getPaymentSuspenseUsers();


    @Operation(summary = "Get Unallocated Payments for an Account", description = "Gets the list of unallocated payments for an account.<p>Both the <b>id</b> parameter and the <b>type</b> query parameter are required.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The unallocated payments were returned successfully.", content = @Content(mediaType = "application/xml", array = @ArraySchema(schema = @Schema(implementation = PaymentList.class)))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/account/{id}",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<PaymentList>> getPayments(@Parameter(in = ParameterIn.PATH, description = "The ID of the account you are retrieving payments for, such as 0.0.0.1+-account+123123.", required=true, schema=@Schema()) @PathVariable("id") String id, @Parameter(in = ParameterIn.QUERY, description = "The type of payments to retrieve. The only supported value is <b>unallocated</b>." ,schema=@Schema()) @Valid @RequestParam(value = "type", required = false) String type);


    @Operation(summary = "Get Suspense Accounts", description = "Gets a list of all payment suspense accounts.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The list of accounts was returned successfully.", content = @Content(mediaType = "application/xml", array = @ArraySchema(schema = @Schema(implementation = SuspenseAccount.class)))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/accounts",
        produces = { "application/xml", "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<SuspenseAccount>> getSuspenseAccounts();


    @Operation(summary = "Create a Payment", description = "Creates a payment for the bill units specified in the body.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The payment was created successfully."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments",
        consumes = { "application/json" }, 
        method = RequestMethod.POST)
    ResponseEntity<Void> makePayment(@Parameter(in = ParameterIn.QUERY, description = "Whether to save the payment method information: <ul><li><b>true</b> specifies to save the payment method information.</li><li><b>false</b> specifies to make the payment without saving the payment method.</li></ul>" ,schema=@Schema()) @Valid @RequestParam(value = "savePaymentType", required = false) Boolean savePaymentType, @Parameter(in = ParameterIn.DEFAULT, description = "The payment to create. Specifies the target bill unit and the payment amount.", schema=@Schema()) @Valid @RequestBody Payment body);


    @Operation(summary = "Create a Suspended Payment", description = "Creates a suspended payment.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "201", description = "The suspended payment was created successfully.", content = @Content(mediaType = "application/json", schema = @Schema(implementation = Payment.class))),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/payment",
        produces = { "application/json", "application/xml" }, 
        consumes = { "application/json" }, 
        method = RequestMethod.POST)
    ResponseEntity<Payment> makeSuspensePayment(@Parameter(in = ParameterIn.DEFAULT, description = "The suspended payment to create.", schema=@Schema()) @Valid @RequestBody Payment body);


    @Operation(summary = "Reverse a Payment", description = "Reverses the payment that matches the specified ID. Payment reversals are needed when a payment is recorded in Billing Care, but the payment isn't deposited, such as when a check payment doesn't clear. Reversing the payment reopens the bill so that the payment can be made again.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "200", description = "The payment was reversed successfully."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/reverse",
        consumes = { "application/json", "application/xml" }, 
        method = RequestMethod.POST)
    ResponseEntity<Void> reversePayment(@Parameter(in = ParameterIn.DEFAULT, description = "The details about the payment to reverse. The minimum required parameters are&colon;<ul><li>eventID</li><li>Notes</li><li>effectiveDate</li></ul>", schema=@Schema()) @Valid @RequestBody ReversePayment body);


    @Operation(summary = "Withdraw a Posted Payment into Suspense", description = "Withdraws a payment that's already been applied to an account into suspense. This allows you to manually resolve errors in a posted payment.", tags={ "Payments" })
    @ApiResponses(value = { 
        @ApiResponse(responseCode = "201", description = "The posted payment was successfully withdrawn into suspense.", content = @Content(mediaType = "application/xml", schema = @Schema(implementation = Resource.class))),
        
        @ApiResponse(responseCode = "400", description = "The request isn't valid."),
        
        @ApiResponse(responseCode = "500", description = "An internal server error occurred.") })
    @RequestMapping(value = "/payments/suspense/withdraw",
        produces = { "application/xml", "application/json" }, 
        consumes = { "application/xml", "application/json" }, 
        method = RequestMethod.POST)
    ResponseEntity<Resource> withdrawPaymentSuspense(@Parameter(in = ParameterIn.DEFAULT, description = "The details about the posted payment to withdraw into suspense. The minimum required parameters are&colon;<ul><li>paymentType</li><li>effectiveDate of withdrawal</li><li>domainId</li><li>reasonID</li></ul>", schema=@Schema()) @Valid @RequestBody WithdrawPayment body);

}

